"""
NPZ Loader - Load and validate NPZ mask files.

This module handles reading .npz files generated by the mask generation pipeline
and extracting the relevant mask arrays and metadata.
"""

import numpy as np
from pathlib import Path
from typing import Dict, Any, Optional
from dataclasses import dataclass


@dataclass
class MaskData:
    """Container for mask arrays and metadata from NPZ file."""
    
    # Required mask arrays (224x224 float32)
    robot: np.ndarray           # Robot position mask
    goal: np.ndarray            # Goal position mask
    movable: np.ndarray         # Movable objects mask
    static: np.ndarray          # Static walls/obstacles mask
    
    # Optional metadata
    episode_id: Optional[str] = None
    task_id: Optional[str] = None
    algorithm: Optional[str] = None
    xml_file: Optional[str] = None
    robot_goal: Optional[np.ndarray] = None  # [x, y, theta]
    
    # Optional masks (not needed for reconstruction but may be present)
    reachable: Optional[np.ndarray] = None
    target_object: Optional[np.ndarray] = None
    target_goal: Optional[np.ndarray] = None
    robot_distance: Optional[np.ndarray] = None
    goal_distance: Optional[np.ndarray] = None
    
    def validate(self) -> bool:
        """Validate that required masks have correct shape and dtype.
        
        Returns:
            True if valid, raises ValueError if invalid
        """
        required_masks = {
            'robot': self.robot,
            'goal': self.goal,
            'movable': self.movable,
            'static': self.static
        }
        
        for name, mask in required_masks.items():
            if mask is None:
                raise ValueError(f"Missing required mask: {name}")
            
            if mask.shape != (224, 224):
                raise ValueError(f"Invalid shape for {name} mask: {mask.shape}, expected (224, 224)")
            
            if not np.issubdtype(mask.dtype, np.floating):
                raise ValueError(f"Invalid dtype for {name} mask: {mask.dtype}, expected float")
            
            # Check value range
            if mask.min() < -1.0 or mask.max() > 1.0:
                print(f"Warning: {name} mask has values outside [-1, 1]: min={mask.min()}, max={mask.max()}")
        
        return True


class NPZLoader:
    """Loads and validates NPZ mask files."""
    
    @staticmethod
    def load(npz_path: str) -> MaskData:
        """Load masks and metadata from NPZ file.
        
        Args:
            npz_path: Path to .npz file
            
        Returns:
            MaskData object with masks and metadata
            
        Raises:
            FileNotFoundError: If file doesn't exist
            ValueError: If required masks are missing or invalid
        """
        path = Path(npz_path)
        if not path.exists():
            raise FileNotFoundError(f"NPZ file not found: {npz_path}")
        
        # Load NPZ file
        data = np.load(npz_path, allow_pickle=True)
        
        # Extract required masks
        try:
            robot = data['robot']
            goal = data['goal']
            movable = data['movable']
            static = data['static']
        except KeyError as e:
            raise ValueError(f"Missing required mask in NPZ file: {e}")
        
        # Extract optional metadata
        episode_id = None
        if 'episode_id' in data:
            episode_id_array = data['episode_id']
            if episode_id_array.size > 0:
                episode_id = str(episode_id_array[0]) if hasattr(episode_id_array[0], '__str__') else str(episode_id_array)
        
        task_id = None
        if 'task_id' in data:
            task_id_array = data['task_id']
            if task_id_array.size > 0:
                task_id = str(task_id_array[0]) if hasattr(task_id_array[0], '__str__') else str(task_id_array)
        
        algorithm = None
        if 'algorithm' in data:
            algorithm_array = data['algorithm']
            if algorithm_array.size > 0:
                algorithm = str(algorithm_array[0]) if hasattr(algorithm_array[0], '__str__') else str(algorithm_array)
        
        xml_file = None
        if 'xml_file' in data:
            xml_file_array = data['xml_file']
            if xml_file_array.size > 0:
                xml_file = str(xml_file_array[0]) if hasattr(xml_file_array[0], '__str__') else str(xml_file_array)
        
        robot_goal = data.get('robot_goal', None)
        
        # Extract optional masks
        reachable = data.get('reachable', None)
        target_object = data.get('target_object', None)
        target_goal = data.get('target_goal', None)
        robot_distance = data.get('robot_distance', None)
        goal_distance = data.get('goal_distance', None)
        
        # Create MaskData object
        mask_data = MaskData(
            robot=robot,
            goal=goal,
            movable=movable,
            static=static,
            episode_id=episode_id,
            task_id=task_id,
            algorithm=algorithm,
            xml_file=xml_file,
            robot_goal=robot_goal,
            reachable=reachable,
            target_object=target_object,
            target_goal=target_goal,
            robot_distance=robot_distance,
            goal_distance=goal_distance
        )
        
        # Validate
        mask_data.validate()
        
        return mask_data
    
    @staticmethod
    def load_batch(npz_paths: list) -> Dict[str, MaskData]:
        """Load multiple NPZ files.
        
        Args:
            npz_paths: List of paths to .npz files
            
        Returns:
            Dictionary mapping file paths to MaskData objects
        """
        results = {}
        failed = []
        
        for npz_path in npz_paths:
            try:
                mask_data = NPZLoader.load(npz_path)
                results[npz_path] = mask_data
            except Exception as e:
                print(f"Failed to load {npz_path}: {e}")
                failed.append((npz_path, str(e)))
        
        if failed:
            print(f"\nFailed to load {len(failed)}/{len(npz_paths)} files")
        
        return results
